import { httpGet, httpPut, httpDelete, httpPost } from '../utils/http';
import Resolver from '.';
import { PaginatedList, DEFAULT_LIST_SIZE } from '../utils/types';
import { buildQueryParams } from '../utils';
import {
  ListResolverOptions,
  ListResolverResponse,
  CrossProjectResolverPayload,
  ResolverResponseCommon,
  ResolverResponse,
  TagResolverPayload,
  ResolverTypes,
  PartialResolverResponse,
} from './types';
import { FetchSpecificOptions } from '../utils/types';

/**
 * Lists resolvers for a project in a paginated way.
 */
export async function listResolvers(
  orgLabel: string,
  projectLabel: string,
  options?: ListResolverOptions,
): Promise<PaginatedList<Resolver>> {
  const opts: string = buildQueryParams(options);
  try {
    const resolverResponse: ListResolverResponse = await httpGet(
      `/resolvers/${orgLabel}/${projectLabel}${opts}`,
    );
    const total: number = resolverResponse._total;
    const index: number = (options && options.from) || 1;
    const resolverIds = resolverResponse._results.map(
      (commonResponse: ResolverResponseCommon) => encodeURIComponent(commonResponse["@id"])
    );

    const results: Resolver[] = await Promise.all(
      resolverIds.map(
        resolverId => getResolver(orgLabel, projectLabel, resolverId)
      )
    );

    return {
      total,
      index,
      results,
    };
  } catch (error) {
    throw error;
  }
}

/**
 * Get a resolver payload.
 *
 * By default, the latest revision if fetched.
 * Specify `rev` in the options to fetch a specific revision.
 * Specify `tag` in the options to fetch the revision with a given tag.
 * These options are mutually exclusive.
 */
export async function getResolver(
  orgLabel: string,
  projectLabel: string,
  resolverId: string,
  options?: FetchSpecificOptions,
): Promise<Resolver> {
  const opts: string = buildQueryParams(options);
  try {
    const resolverResponse: ResolverResponse = await httpGet(
      `/resolvers/${orgLabel}/${projectLabel}/${resolverId}${opts}`,
    );
    return new Resolver(orgLabel, projectLabel, resolverResponse);
  } catch (error) {
    throw error;
  }
}

/**
 * Creates a Cross-Project Resolver.
 *
 * When using POST, an @id will be autogenerated if not present in the payload.
 * When using PUT, not having an @id will cause an error.
 * If an @id is present, it will be used in both POST and PUT methods.
 *
 * It does not make sense to create an InProject resolver since it already exists
 * in each project and only one is needed.
 */
export async function createResolver(
  orgLabel: string,
  projectLabel: string,
  resolverId: string | null,
  resolverPayload: CrossProjectResolverPayload,
  method: "POST" | "PUT" = "PUT",
): Promise<Resolver> {
  try {
    const httpRequest = method === "POST" ? httpPost : httpPut;
    const url = `/resolvers/${orgLabel}/${projectLabel}${resolverId && method === "PUT" ? `/${resolverId}` : ''}`;
    const resolverResponse: PartialResolverResponse = await httpRequest(
      url,
      resolverPayload,
    );
    return new Resolver(orgLabel, projectLabel, { ...resolverResponse, ...resolverPayload });
  } catch (error) {
    throw error;
  }
}

/**
 * Overwrites a resolver's payload.
 *
 * Need to pass the latest revision ID to make sure the latest state
 * was accounted for.
 */
export async function updateResolver(
  orgLabel: string,
  projectLabel: string,
  resolverId: string,
  previousRev: number,
  resolverPayload: CrossProjectResolverPayload,
): Promise<Resolver> {
  try {
    const resolverResponse: PartialResolverResponse = await httpPut(
      `/resolvers/${orgLabel}/${projectLabel}/${resolverId}?rev=${previousRev}`,
      resolverPayload,
    );
    return new Resolver(orgLabel, projectLabel, { ...resolverResponse, ...resolverPayload });
  } catch (error) {
    throw error;
  }
}

/**
 * Links a resolver revision to a specific name.
 *
 * Tagging a resolver is considered to be an update as well.
 *
 * @returns an updated Resolver
 */
export async function tagResolver(
  orgLabel: string,
  projectLabel: string,
  resolverId: string,
  previousRev: number,
  tagPayload: TagResolverPayload,
): Promise<Resolver> {
  try {
    const resolverResponse: PartialResolverResponse = await httpPost(
      `/resolvers/${orgLabel}/${projectLabel}/${resolverId}/tags?rev=${previousRev}`,
      tagPayload,
    );
    const newRevision = resolverResponse._rev;

    // Get the full Resolver object for the updated object, as original response lacks info
    const updatedResolver = getResolver(orgLabel, projectLabel, resolverId, {"rev": newRevision});
    return updatedResolver;
  } catch (error) {
    throw error;
  }
}

/**
 * Locks the resolver, so no further operations can be performed.
 * It will also not be taken into account in the resolution process.
 *
 * Deprecating a resolver is considered to be an update as well.
 *
 * @returns an updated Resolver
 */
export async function deprecateResolver(
  orgLabel: string,
  projectLabel: string,
  resolverId: string,
  previousRev: number,
): Promise<Resolver> {
  try {
    const resolverResponse: PartialResolverResponse = await httpDelete(
      `/resolvers/${orgLabel}/${projectLabel}/${resolverId}?rev=${previousRev}`
    );
    const newRevision = resolverResponse._rev;

    // Get the full Resolver object for the updated object, as original response lacks info
    const updatedResolver = getResolver(orgLabel, projectLabel, resolverId, {"rev": newRevision});
    return updatedResolver;
  } catch (error) {
    throw error;
  }
}

export const normalizeType = (type: string): string => <string>type.split("/").pop();

export const isValidType = (normalizedType: string): normalizedType is ResolverTypes => {
  return ["InProject", "CrossProject"].includes(normalizedType);
};
